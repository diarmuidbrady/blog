{
  "hash": "c2cb1d6d29faa20486ea1be736feb83d",
  "result": {
    "markdown": "---\ntitle: \"After 5 years of Python, here’s what a beginner course taught me.\"\nauthor: \"Diarmuid Brady\"\ndate: \"2024-07-08\"\ncategories: [Coding]\nimage: \"python_course.png\"\ndraft: False\n---\n\nWhen you observe masters of any skill, they always have a strong grasp of the fundamentals. \n\nBut when we’re learning new skills, we’re eager to move on to the most exciting areas. We get distracted by the attractive parts of the skill, we neglect the simple basics, and this stunts our progress. I believe that to master any skill, you must continually refine the basics because the highest peak has the strongest base.\n\nPython was a large aspect of my BSc in Data Science. I've continued to strengthen my basics through internships, personal projects, and in my current job. However, I've noticed I've become habitual in my choice of tools, using the same knowledge repeatedly. The course, \"Python For Data Science, AI & Development\" on Coursera, exposed the gaps in my knowledge and refreshed my understanding of the core topics.\n\n### Learning Outcomes\nYou'll learn something interesting in all three sections.\n\n1. [Make the cool loading symbol you see when downloading new libraries.](#escape--the-syntaxerror-)\n2. [Handle the invalid key error in dictionaries effectively.](#get-rid-of-the-keyerror)\n3. [Design better functions.](#amazing-arguments)\n\n::: {.callout-caution title=\"Disclaimer...\"}\nThis is not a Python tutorial, you need some Python knowledge. Think of this as a curious exploration of random areas of Python.\n:::\n\n## Escape `\\` the *SyntaxError* !\n\nWhen working with strings, the escape character `\\` (backslash) is a handy way to include special characters in your strings. The backslash changes the meaning of the next character. You can also avoid syntax errors by using the backslash!\n\nIn Python, apostrophes and quotation marks must come in pairs. Unpaired quotation marks create syntax errors. The example below returns a syntax error because the apostrophe in \"friend's\" is unmatched.\n\n```python\nprint('Jimmy borrowed his friend's phone')\n\n```\n\n```python\nSyntaxError: unterminated string literal (detected at line 1)\n```\n\nTo solve this dilemma, use one of the following:\n\n```python\n# Just use double quotes silly!\nprint(\"Jimmy borrowed his friend's phone.\")\n\n# Triple single quotes to allow multi-line strings.\nprint('''\nJimmy borrowed his friend's phone.\n''')\n                                            \n# Triple double quotes if I'm feeling fancy ¯\\_(ツ)_/¯\n# Or if it's a docstring as per PEP 257\nprint(\"\"\"\nJimmy borrowed his friend's phone.\n\"\"\")\n```\n\nBut wait! There's one more I had forgotten about...the escape character.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nprint('Jimmy borrowed his friends\\'s phone.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJimmy borrowed his friends's phone.\n```\n:::\n:::\n\n\nVoilà! Problem solved. For the record, double quotes is my preference for greater readability.\n\n---\n\nThere are many escape characters, including `\\t` (tab space), `\\n` (newline) and `\\'`. Another escape character is the carriage return, `\\r`. It moves the cursor to the start of the current line and proceeds to overwrite the text.\n\nNow you can create the cool loading symbol that appears when installing a library from Pip or Conda!\n\nRun the following code in a Python file, and you'll see the loading symbol on the right.\n\n:::: {.columns}\n\n::: {.column width=\"65%\"}\n\n```python\nimport time\n\nloading = ['|', '/', '-', '\\\\']\nfor i in range(50):\n    print(f\"{loading[i % len(loading)]}\\r\")\n    time.sleep(0.2)\n```\n\n:::\n\n::: {.column width=\"10%\"}\n\n\n:::\n\n::: {.column width=\"25%\"}\n \n<div style=\"text-align: center;padding-top:60px\">\n<img src=\"rotating-line.gif\" alt=\"Loading symbol\" style=\"width: 150px; height: auto; border: 2px solid white;\">\n</div>\n:::\n\n:::\n\n\n## `get()` rid of the *KeyError*!\nDictionaries are one of my favourite data structures in Python. They are intuitive, useful, and efficient. After creating a dictionary, you can add, update, or delete key-value pairs. Please see the code example below.\n\n::: {.callout-note title=\"Colour or color? That is the question.\"}\nI write colour as color when coding Python because the language is written in American English as opposed to UK English. I thought I would point this out before the grammar police get me!\n:::\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Create the dictionary using empty curly brackets.\ndict_color_code = {}\n\n# Add a key-value pair using square brackets of white and the hex color code\ndict_color_code['white'] = '#FFFFFF'\n\n# Find the hex color code of white using square brackets\nprint(f\"White hex color code: {dict_color_code['white']}\")\n\n# Let's update the value for white\ndict_color_code['white'] = '#F8F6F0'\n\nprint(f\"New value for white: {dict_color_code['white']}\")\n\n# Now let's remove white\n# Pop will return the value of the key 'white'\ndict_color_code.pop('white')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWhite hex color code: #FFFFFF\nNew value for white: #F8F6F0\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n'#F8F6F0'\n```\n:::\n:::\n\n\nAbove, I demonstrated the basic actions of the dictionary. We finished by deleting the key we had created. Now let's try to fetch that key-value.\n```python\n# Check that white is not there\nprint(dict_color_code['white'])\n```\n```python\nKeyError: 'white'\n```\n\nImagine that I want to avoid this error. I could check if the key is in the dictionary first:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nk = 'white'\nif k in dict_color_code:\n    print(dict_color_code[k])\n```\n:::\n\n\nLucky for us, we have the `get()` dictionary method. `get()` returns the value of a given key and `None` if the key doesn't exist.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(dict_color_code.get('white'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNone\n```\n:::\n:::\n\n\nThese are two solutions to the same problem. I prefer the `get()` method as it handles non-existent keys. The approach you choose is up to you.\n\n## Amazing Arguments\nA function is a great way of automating mundane tasks. They are a key part of writing concise, readable, and reproducible code.\n\nIn recent versions of Python, there have been updates made to how arguments are used. Firstly, there are two types of arguments:\n\n- Positional: passed first in the function call and are identified using order.\n- Keyword: passed after positional arguments and are identified by name.\n\n::: {.callout-important title=\"Important Rule\"} \n\nPostional arguments must ALWAYS come before keyword arguments. Specifying a positional argument before keyword arguments results in an error.\n\n:::\n\nLet's define a handy function below. I actually used this the other day!\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef check_substring(\n    s:str               # a string\n    ,substrings:[]      # a list of substrings\n    ,all_strings: bool = False  # a boolean to choose between all and any\n    ):\n    \"\"\"\n    Checks if a list of substrings is present in a string. \n    If all_strings, all substrings must be present in s to return True.\n    Else, there must be at least one occurance to return True.\n    \"\"\"\n\n    if all_strings: return all([substring in s for substring in substrings])\n    else: return any([substring in s for substring in substrings])\n```\n:::\n\n\nThis function has three parameters. All arguments can be specified as positional or keyword. `all_strings` is the only argument with a default value (False).\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nsubstrings = ['man', 'ant', 'who']\ns = 'Maniac is a brilliant TV show.' # Some substrings present\n\n# This is how I call the function whe  all_strings is False\nprint(f'any substrings in s: {check_substring(s, substrings)}')\n\n# This is how I call the funciton when all_strings is True\nprint(f'all substrings in s: {check_substring(s, substrings, all_strings=True)}')\n\n# I usually use positional arguments for the first few, then keywords\n# Let's use all keywords to show that works too\nprint(f\"any substrings in s: {check_substring(s=s, substrings=substrings, all_strings=False)}\")\n\n# And all positional for completeness\nprint(f\"any substrings in s: {check_substring(s, substrings, False)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nany substrings in s: True\nall substrings in s: False\nany substrings in s: True\nany substrings in s: True\n```\n:::\n:::\n\n\nNow I'd like to make two changes.\n\n1. I want all_strings to be a keyword-only argument.\n2. I want to pass each substring as an argument rather than as part of a list. \n\n`*` solves both issues. See the example below.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef check_substring(\n    s:str               # a string\n    ,*substrings      # an interable tuple of substrings (note: *)\n    ,all_strings: bool = False  # a boolean to choose between all and any\n    ):\n    \"\"\"\n    Checks if a tuple of substrings is present in a string. \n    If all, all substrings must be present in s to return True.\n    Else, there must be at least one occurance to return True.\n    \"\"\"\n\n    if all_strings: return all([substring in s for substring in substrings])\n    else: return any([substring in s for substring in substrings])\n```\n:::\n\n\nNow all_strings must be passed as a keyword (never positional). This is helpful because code readability is important. While this function only has three arguments, there are many functions with too many arguments to count. Thus, using positional arguments wouldn't make sense and would be a pain to decipher in those cases.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ns = 'Maniac is a brilliant TV show.' # Some substrings present\n\n# Now we can add substrings manually to the function call.\nprint(f\"any substrings in s: {check_substring(s, 'man', 'ant', 'who')}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nany substrings in s: True\n```\n:::\n:::\n\n\nEverything works dandy above, but what happens if we do pass all_substrings as a positional argument?\n\nLet's fuck around and find out!\n```python\n# now let's change all to True\nprint(f\"all substrings in s: {check_substring(s, 'li', 'gr', 'te', True)}\")\n```\n\n```python\nTypeError: 'in <string>' requires string as left operand, not bool\n```\n\nPython interpreted False as being part of the *substrings argument. It expected a string but instead got a bool (and it was not happy). When we use `*`, all succeeding positional arguments are assumed to be part of the same set (in this case, substrings). That's why all the remaining arguments must be passed using keywords.\n\nWe could remove the default value for `all_strings`, then it'd be a required (rather than optional) keyword-only argument. \n\n`**` collects all the optional keyword-only arguments into a dictionary. With `**`, there is no need to specify all keywords that have default values. The code will be more concise as a result.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndef get_connection_string(self, **kwargs):\n    \"\"\"Get the connection string for a database\"\"\"\n    con_string = f\"{kwargs.get('user')}:{kwargs.get('password')}\\\n        @{kwargs.get('host')}/{kwargs.get('myschema')}\"\n\n    return con_string\n```\n:::\n\n\nWe have now covered four types of arguments.\n\n| Label | Argument Type |\n|:-----:|:-------------|\n|1| Positional arguments|\n|2| Tuple of positional arguments|\n|3| Keyword-only arguments|\n|4| Dictionary of optional keyword arguments|\n\n```python\n# parg: Positional argument\n# kwarg: Keyword arguments\n\ndef function_with_all_argument_types(\n    #<----  1  ---->\n    arg1, arg2, ..., \n\n    #<- 2 ->\n    *args, \n\n    #<------ 3 ------->\n    kwarg1, kwarg2, ..., \n\n    #<-- 4 -->\n    **kwargs\n    )\n    return\n```\n\n## Conclusion\nThat wraps up this post. I hope you learned something new from these three random Python topics. \n\nNow you know how to use the escape character in string manipulation, the get() method when using dictionaries, and all types of arguments when writing a function.\n\nThink about a skill you take for granted, what could you do to refresh your basics?\n\nIf you have any feedback on what you learned, an error you spotted, or ideas for what you'd like me to write about next, let me know!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}